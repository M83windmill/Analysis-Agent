# Agent 学习路径

> 这份文档帮助你从零理解 Agent 架构，重点是**理解原理**而非实现功能。

**学完后自测**: 完成学习后，请做 [QUIZ.md](./QUIZ.md) 中的自测题检验理解程度。

---

## 第一章：Agent 到底是什么？

### 1.1 一句话定义

```
Agent = LLM + 工具调用 + 循环决策
```

### 1.2 与普通 Chatbot 的本质区别

**普通 Chatbot**:
```
用户: "苹果2023年收入是多少？"
LLM:  "根据我的训练数据，苹果2023年收入约为3830亿美元..." (可能过时/编造)
```

**Agent**:
```
用户: "苹果2023年收入是多少？"

Agent 思考: "我需要查财报才能准确回答"
Agent 行动: 调用 search_tool("苹果 2023 收入")
工具返回: "根据年报第15页，2023财年总收入为383,285百万美元"
Agent 思考: "找到了准确数据，可以回答了"
Agent 回答: "苹果2023财年收入为3832.85亿美元 [来源: 年报第15页]"
```

**关键区别**:
| 维度 | Chatbot | Agent |
|------|---------|-------|
| 数据来源 | 只用模型记忆 | 能检索外部数据 |
| 能力边界 | 只能生成文字 | 能调用工具执行任务 |
| 决策方式 | 一次性输出 | 多轮思考-行动循环 |
| 可靠性 | 可能幻觉 | 基于证据，可追溯 |

### 1.3 Agent 的核心能力

```
┌─────────────────────────────────────────────┐
│                   Agent                     │
│                                             │
│   ┌─────────┐   ┌─────────┐   ┌─────────┐  │
│   │  感知   │   │  思考   │   │  行动   │  │
│   │ Perceive│   │  Think  │   │   Act   │  │
│   └────┬────┘   └────┬────┘   └────┬────┘  │
│        │             │              │       │
│   接收用户输入   LLM推理决策    调用工具执行  │
│   获取环境信息   制定计划       返回结果      │
│                                             │
└─────────────────────────────────────────────┘
```

---

## 第二章：函数调用 (Tool Use) - Agent 的核心

> 这是整个 Agent 架构中**最重要**的概念，必须彻底理解。

### 2.1 什么是函数调用？

函数调用让 LLM 从"只会说"变成"能动手"：

```python
# 没有函数调用时
response = openai.chat("计算 15% 的 1000")
# LLM 只能回答: "15% 的 1000 是 150"（靠自己算，可能出错）

# 有函数调用时
response = openai.chat(
    message="计算 15% 的 1000",
    tools=[calculator_tool]  # 告诉LLM有计算器可用
)
# LLM 会返回: "我要调用 calculator(0.15, 1000)"
# 你执行计算器，把结果喂回去
# LLM 基于真实结果回答: "15% 的 1000 是 150"
```

### 2.2 函数调用的工作流程

```
┌────────────────────────────────────────────────────────────────┐
│ 第1步: 定义工具 (你做)                                          │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  tools = [{                                                    │
│      "type": "function",                                       │
│      "function": {                                             │
│          "name": "search_report",        # 工具名称             │
│          "description": "搜索财报内容",   # 告诉LLM这工具干啥    │
│          "parameters": {                  # 需要什么参数        │
│              "type": "object",                                 │
│              "properties": {                                   │
│                  "query": {"type": "string"},                  │
│                  "year": {"type": "integer"}                   │
│              },                                                │
│              "required": ["query"]                             │
│          }                                                     │
│      }                                                         │
│  }]                                                            │
│                                                                │
└────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌────────────────────────────────────────────────────────────────┐
│ 第2步: 调用 LLM (带上工具定义)                                   │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  response = client.chat.completions.create(                    │
│      model="gpt-4",                                            │
│      messages=[{"role": "user", "content": "苹果去年收入?"}],   │
│      tools=tools  # 把工具列表传给 LLM                          │
│  )                                                             │
│                                                                │
└────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌────────────────────────────────────────────────────────────────┐
│ 第3步: LLM 决定是否调用工具                                      │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  # 如果 LLM 觉得需要工具，它不会直接回答，而是返回:              │
│  response.choices[0].message.tool_calls = [                    │
│      {                                                         │
│          "id": "call_abc123",                                  │
│          "function": {                                         │
│              "name": "search_report",                          │
│              "arguments": '{"query": "收入", "year": 2023}'    │
│          }                                                     │
│      }                                                         │
│  ]                                                             │
│                                                                │
│  # 如果 LLM 觉得不需要工具，直接返回答案                         │
│                                                                │
└────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌────────────────────────────────────────────────────────────────┐
│ 第4步: 执行工具 (你做)                                          │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  # 解析 LLM 返回的工具调用                                      │
│  tool_call = response.choices[0].message.tool_calls[0]         │
│  func_name = tool_call.function.name                           │
│  args = json.loads(tool_call.function.arguments)               │
│                                                                │
│  # 执行对应的函数                                               │
│  if func_name == "search_report":                              │
│      result = search_report(**args)                            │
│      # result = "年报第15页: 2023财年收入383,285百万美元"       │
│                                                                │
└────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌────────────────────────────────────────────────────────────────┐
│ 第5步: 把结果喂回 LLM                                           │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  messages.append(response.choices[0].message)  # LLM的工具调用  │
│  messages.append({                                             │
│      "role": "tool",                                           │
│      "tool_call_id": "call_abc123",                            │
│      "content": result  # 工具执行结果                          │
│  })                                                            │
│                                                                │
│  # 再次调用 LLM，让它基于工具结果生成最终答案                    │
│  final_response = client.chat.completions.create(              │
│      model="gpt-4",                                            │
│      messages=messages                                         │
│  )                                                             │
│                                                                │
└────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌────────────────────────────────────────────────────────────────┐
│ 第6步: LLM 生成最终答案                                         │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  "苹果2023财年收入为3832.85亿美元。[来源: 年报第15页]"          │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### 2.3 关键理解点

1. **LLM 不执行工具** - 它只是"说"要调用什么工具、传什么参数
2. **你负责执行** - 解析 LLM 的指令，执行真正的函数，返回结果
3. **LLM 决定何时调用** - 基于用户问题和工具描述，LLM 自己判断需不需要工具
4. **工具描述很重要** - 描述写得好，LLM 才知道什么时候该用这个工具

---

## 第三章：ReAct 循环 - Agent 的决策引擎

### 3.1 什么是 ReAct？

**ReAct = Reasoning + Acting**

LLM 交替进行"推理"和"行动"，直到任务完成：

```
┌─────────────────────────────────────────────────────────────┐
│                      ReAct 循环                              │
│                                                              │
│    ┌──────────┐     ┌──────────┐     ┌──────────┐          │
│    │ Thought  │────▶│  Action  │────▶│Observation│          │
│    │  (思考)  │     │  (行动)  │     │  (观察)   │          │
│    └──────────┘     └──────────┘     └────┬─────┘          │
│         ▲                                  │                │
│         │                                  │                │
│         └──────────────────────────────────┘                │
│                    (循环直到完成)                            │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 实际例子

用户问: **"苹果2023年的毛利率是多少？和2022年比有什么变化？"**

```
═══════════════════════════════════════════════════════════════
第1轮
═══════════════════════════════════════════════════════════════
Thought: 用户问毛利率和同比变化，我需要:
         1. 找到2023年的毛利率
         2. 找到2022年的毛利率
         3. 计算变化
         先搜索2023年的数据

Action:  search_report(query="毛利率 gross margin", year=2023)

Observation: "2023财年毛利率为44.1%，毛利润为169,148百万美元"

═══════════════════════════════════════════════════════════════
第2轮
═══════════════════════════════════════════════════════════════
Thought: 找到2023年是44.1%，现在需要2022年的数据

Action:  search_report(query="毛利率 gross margin", year=2022)

Observation: "2022财年毛利率为43.3%，毛利润为170,782百万美元"

═══════════════════════════════════════════════════════════════
第3轮
═══════════════════════════════════════════════════════════════
Thought: 两年数据都有了:
         - 2023: 44.1%
         - 2022: 43.3%
         需要计算变化幅度

Action:  calculate(expression="44.1 - 43.3")

Observation: 0.8

═══════════════════════════════════════════════════════════════
第4轮
═══════════════════════════════════════════════════════════════
Thought: 所有信息都齐了，可以回答用户了:
         - 2023年毛利率: 44.1%
         - 同比提升: 0.8个百分点

Final Answer:
苹果2023财年毛利率为44.1%，较2022年的43.3%提升了0.8个百分点。
[来源: 2023年报, 2022年报]
```

### 3.3 代码实现框架

```python
def react_loop(user_question, tools, max_iterations=10):
    """ReAct 循环的核心实现"""

    messages = [
        {"role": "system", "content": SYSTEM_PROMPT},
        {"role": "user", "content": user_question}
    ]

    for i in range(max_iterations):
        # 调用 LLM
        response = client.chat.completions.create(
            model="gpt-4",
            messages=messages,
            tools=tools
        )

        assistant_message = response.choices[0].message
        messages.append(assistant_message)

        # 检查是否需要调用工具
        if assistant_message.tool_calls:
            # 执行工具
            for tool_call in assistant_message.tool_calls:
                result = execute_tool(tool_call)
                messages.append({
                    "role": "tool",
                    "tool_call_id": tool_call.id,
                    "content": result
                })
        else:
            # 没有工具调用，说明 LLM 准备好回答了
            return assistant_message.content

    return "达到最大迭代次数，未能完成任务"
```

### 3.4 防止死循环的策略

```python
# 1. 设置最大迭代次数
max_iterations = 10

# 2. 在 System Prompt 中明确指示
SYSTEM_PROMPT = """
...
重要规则:
- 如果连续3次搜索都找不到答案，直接告诉用户"无法找到相关信息"
- 不要重复调用相同的工具和参数
- 如果计算结果不合理，说明可能存在问题而不是继续尝试
"""

# 3. 记录已调用的工具，避免重复
called_tools = set()
```

---

## 第四章：学习步骤

### 阶段1: 理解函数调用 (第1-2天)

**目标**: 彻底理解 Tool Use 机制

| 顺序 | 文件 | 学习内容 | 核心知识点 |
|-----|------|---------|-----------|
| 1 | `src/tools/base.py` | 工具的标准定义 | JSON Schema、工具描述 |
| 2 | `src/tools/calculator.py` | 第一个工具实现 | 参数解析、结果返回 |
| 3 | `src/agent/simple_agent.py` | 最小Agent | 完整调用流程 |

**动手练习**:
```python
# 1. 定义一个简单的工具
# 2. 调用 OpenAI API，传入工具定义
# 3. 观察 LLM 的返回结构
# 4. 执行工具，把结果喂回去
# 5. 获得最终答案
```

**学完能回答**:
- 函数调用的5个步骤是什么？
- LLM 怎么知道应该调用哪个工具？
- 工具的 description 为什么重要？

---

### 阶段2: 理解 Agent 循环 (第3-4天)

**目标**: 理解 ReAct 模式，实现多轮工具调用

| 顺序 | 文件 | 学习内容 | 核心知识点 |
|-----|------|---------|-----------|
| 4 | `src/agent/orchestrator.py` | 完整ReAct循环 | 循环控制、状态管理 |
| 5 | `src/tools/retrieval.py` | 检索工具(模拟) | 工具串联 |
| 6 | `prompts/system.txt` | Prompt工程 | 指令设计 |

**动手练习**:
```python
# 1. 实现一个需要多次工具调用才能回答的场景
# 2. 观察 LLM 的思考过程
# 3. 尝试让 Agent 陷入死循环，然后修复它
```

**学完能回答**:
- ReAct 是什么？为什么比单次调用好？
- 如何防止 Agent 死循环？
- Agent 如何决定"够了，可以回答了"？

---

### 阶段3: 加入 RAG (第5-6天)

**目标**: 让 Agent 能检索真实文档

| 顺序 | 文件 | 学习内容 | 核心知识点 |
|-----|------|---------|-----------|
| 7 | `src/ingestion/chunker.py` | 文档切分 | chunk策略、重叠 |
| 8 | `src/index/vector_store.py` | 向量存储 | ChromaDB、相似度 |
| 9 | `src/tools/retrieval.py` | 真实检索工具 | top-k、元数据过滤 |

**动手练习**:
```python
# 1. 把一份财报切成 chunks
# 2. 存入向量数据库
# 3. 测试检索效果
# 4. 接入 Agent 的检索工具
```

**学完能回答**:
- chunk size 怎么选？为什么？
- 向量检索 vs 关键词检索？
- 如何提高检索准确率？

---

### 阶段4: 完善功能 (第7-8天)

| 顺序 | 文件 | 学习内容 |
|-----|------|---------|
| 10 | `src/synthesis/answer.py` | 生成带引用的答案 |
| 11 | `src/interface/cli.py` | 命令行交互 |
| 12 | `tests/test_agent.py` | 测试和评估 |

---

## 第五章：面试必问 & 答案要点

### Q1: 介绍一下你的 Agent 架构？

**答题框架**:
```
1. 整体架构图 (画出来)
2. 核心是 ReAct 循环
3. 工具包括: 检索、计算、表格抽取
4. RAG 提供知识支持
5. 防幻觉机制
```

### Q2: Tool Use 是怎么实现的？

**要点**:
1. 用 JSON Schema 定义工具的名称、描述、参数
2. 把工具定义传给 LLM
3. LLM 返回要调用的工具名和参数（不是执行）
4. 我们执行工具，把结果追加到对话
5. LLM 基于工具结果继续处理或生成答案

### Q3: 为什么用 RAG 而不是直接把财报塞给 LLM？

**要点**:
1. **长度限制**: 财报几十页，超过 context window
2. **成本考虑**: 全塞进去每次调用都花很多钱
3. **精准度**: 检索后只喂相关段落，噪音更少
4. **可追溯**: 能标注答案来自哪一页哪一段

### Q4: 如何防止 Agent 幻觉？

**要点**:
1. System Prompt 明确要求"没有证据就说不知道"
2. 每个结论必须带引用来源
3. 检索结果为空时返回"需要更多信息"
4. 数值计算用工具而不是让 LLM 自己算

### Q5: chunk size 怎么选？

**要点**:
1. 太小: 语义不完整，检索到也没用
2. 太大: 混入无关信息，浪费 token
3. 财报场景: 500-1000 tokens，按段落切分
4. 加重叠 (overlap): 100-200 tokens，防止切断关键信息

### Q6: 遇到过什么问题？怎么解决的？

**准备2-3个真实例子**:
- "Agent 死循环" → 加最大迭代次数 + prompt约束
- "检索不准" → 混合检索 + 章节优先
- "数值计算错误" → 用计算工具而非LLM直接算

---

## 第六章：进阶话题（可选）

### 6.1 多 Agent 协作
- Router Agent 分发任务
- 专家 Agent 处理细分领域

### 6.2 记忆机制
- 短期记忆: 对话上下文
- 长期记忆: 用户偏好、历史问答

### 6.3 评估体系
- 检索准确率 (Recall@k)
- 答案正确率 (人工标注)
- 幻觉率

---

## 下一步

准备好开始了吗？

从 `src/tools/base.py` 开始，写你的第一个工具定义。
